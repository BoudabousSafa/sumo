<a id="top"></a>

						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">Developer/Debugging</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Sumo</div>
								<div id="contentSub"></div>
												
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>Besides using a debugger (e.g. <a rel="nofollow" class="external text" href="https://www.gnu.org/s/gdb/">gdb</a>) with the debug build (see below), the SUMO source code offers debugging macros at several locations, which are usually deactivated (e.g., commented out). Activating the macros can yield a detailed program output, that can be configured by given parameters.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Debug_Build">Debug Build</span></h2>
<p>To create debugging symbols during the build, see the build instructions for your operating system (<a href="../Installing/Linux_Build.html" title="Installing/Linux Build">Linux</a> / <a href="../Installing/Windows_Build.html" title="Installing/Windows Build">Windows</a> / <a href="../Installing/MacOS_Build.html" title="Installing/MacOS Build">MacOS</a>). The corresponding binaries receive the suffix <code>D</code> (e.g. <code>sumoD</code> instead of <code>sumo</code>).
The debug configuration defines a preprocessor macro <code>_DEBUG</code> that may be used to encapsulate debug specific code. For simple text debugging, local macros should be used that can be switched on and off more flexibly, see below.
</p>
<h2><span class="mw-headline" id="Local_Debug_Macros">Local Debug Macros</span></h2>
<p>The recommended style for inserting reusable debugging code in SUMO is encapsulation by preprocessor directives. This is done by placing a <code>#define DEBUG_THIS_CODE</code> at the beginning of a source (preferably just below any other <code>#include</code> or <code>#define</code> macros). The debugging code (e.g. some output to <code>std::cout</code>) should then be surrounded by 
</p>
<pre>#ifdef DEBUG_THIS_CODE
    ...
#endif
</pre>
<p>Thus, it can be switched on and off by (un)commenting the <code>#define DEBUG_THIS_CODE</code> line.
</p><p>Sometimes it is useful to combine this with a condition for more specific debugging output. For instance, if only output for the vehicle with ID 'my_new_ferrari' is needed while looping through all vehicles, you should insert a corresponding debug condition
</p><p><code>#define DEBUG_COND (veh.getID() == "my_new_ferrari")</code> 
</p><p>(at the same location as the <code>#define DEBUG_THIS_CODE</code>) and encapsulate the debug code further as 
</p>
<pre>#ifdef DEBUG_THIS_CODE
    if DEBUG_COND {
        ...
    }
#endif
</pre>
<p>Note that this presupposes that <code>veh</code> is a reference to the current vehicle, which is being looped over. It is worth mentioning that you can also define debug conditions with arguments to become a bit more flexible. For example:
</p>
<pre>#define DEBUG_COND(x) (x != 0 &amp;&amp; x-&gt;getID() == &quot;my_new_ferrari&quot;)
    ...
#ifdef DEBUG_THIS_CODE
    if DEBUG_COND(veh_pointer) {
        ...
    }
#endif
</pre>
<p>Debugging macros already exist at several locations (see some of these before implementing your own):
</p>
<ul><li> src/microsim/MSLane.cpp </li>
<li> src/microsim/MSLink.cpp </li>
<li> src/microsim/MSVehicle.cpp </li>
<li> src/microsim/lcmodel/MSLCM_LC2013.cpp</li>
<li> src/guisim/GUIVehicle.cpp</li>
<li> src/guisim/GUILane.cpp</li></ul>
<h2><span class="mw-headline" id="Selection_based_vehicle_debugging">Selection based vehicle debugging</span></h2>
<p>The header <code>utils/common/StdDefs.h</code> provides the String <code>gDebugSelectedVehicle</code>, which always holds the id of the last vehicle, which was selected in the GUI, and can be used in the debugging conditions to obtain a dynamic debugging selection (provided the corresponding macro is activated).
</p>
<!-- 
NewPP limit report
CPU time usage: 0.012 seconds
Real time usage: 0.011 seconds
Preprocessor visited node count: 38/1000000
Preprocessor generated node count: 76/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key sumoSimWiki:pcache:idhash:751-0!*!0!!*!*!* and timestamp 20181010222102 and revision id 8169
 -->
</div>									</div><hr/><div id="lastmod">This page was last modified on 26 October 2016, at 15:33.</div>